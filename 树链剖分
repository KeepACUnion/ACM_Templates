//题目spoj qtree, 单边修改, 路径查询最大值, 用每个节点代表他们跟父亲的边


//const int maxn = 10010;
int siz[maxn], top[maxn], son[maxn], dep[maxn], fa[maxn];
int val[maxn*2], tid[maxn], rk[maxn], head[maxn*2];
int to[maxn*2], nxt[maxn*2], idx, tim;

struct Edge
{
    int u,v,c;
} tmp[maxn];
void add_edge(int u, int v, int Val, int idx)
{
    to[idx] = v;  nxt[idx] = head[u];
    val[idx] = Val; head[u] = idx;
}
void dfs1(int u, int fth, int d)
{
    dep[u] = d;
    fa[u] = fth;
    siz[u] = 1;
    for(int i = head[u]; i; i = nxt[i]){
        int v = to[i];
        if(v == fth) continue;
        dfs1(v, u, d+1);
        siz[u] += siz[v];
        if(son[u] < 0 || siz[v] > siz[son[u]]) son[u] = v;
    }
}

void dfs2(int u, int tp)
{
    top[u] = tp;
    tid[u] = ++tim;
    rk[tid[u]] = u;
    if(son[u] == -1) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i; i = nxt[i]){
        int v = to[i];
        if(v == son[u] || v == fa[u]) continue;
        dfs2(v,v);
    }
}

//sgt
int sgt[maxn*4], sgt_sz;
void init()
{
    idx = 1;
    tim = 0;
    memset(head, 0, sizeof(head));
    memset(son, -1, sizeof(son));
}
void tree_init(int up)
{
    sgt_sz = 1;
    while(sgt_sz < up) sgt_sz *= 2;
    memset(sgt, -1*INF, sizeof(sgt));
}

void build(int rt, int l, int r)
{
    if(l == r){
        return;
    }
    build(rt*2+1, l, mid);
    build(rt*2+2, mid+1, r);
    sgt[rt] = max(sgt[rt*2+1], sgt[rt*2+2]);
}

void update(int k, int Val)
{
    k += sgt_sz-1;
    sgt[k] = Val;
    while(k){
        k = (k-1)/2;
        sgt[k] = max(sgt[k*2+1], sgt[k*2+2]);
    }
}

//修改边权
void change(int x, int Val)
{
    int u = tmp[x].u, v = tmp[x].v;
    if(dep[u] > dep[v])
        update(tid[u], Val);
    else
        update(tid[v], Val);
}

int query(int x, int y, int rt, int l, int r)
{
    if(l > y || r < x) return -INF;
    if(l >= x && r <= y) return sgt[rt];
    int ans = max(query(x,y,rt*2+1,l,mid),query(x,y,rt*2+2,mid+1,r));
    return ans;
}

int solve(int x, int y)
{
    int ans = -INF;
    while(top[x] != top[y]){
        if(dep[top[x]] < dep[top[y]]) swap(x,y);
        ans = max(ans, query(tid[top[x]], tid[x], 0, 0, sgt_sz-1));
        x = fa[top[x]];
    }
    if(dep[x] > dep[y]) swap(x,y);
    if(x != y) ans = max(ans, query(tid[x]+1, tid[y], 0, 0, sgt_sz-1));
    return ans;
}


int main()
{
    //frein;
    //freout;
    int t; scanf("%d", &t);
    while(t--){
        init();
        int n; sc(n);
        for(int i = 1; i < n; i++){
            int u,v,c;
            scanf("%d%d%d", &u, &v, &c);
            tmp[i].u = u; tmp[i].v = v; tmp[i].c = c;
            add_edge(u,v,c,idx++);
            add_edge(v,u,c,idx++);
        }
        dfs1(1,1,1);
        dfs2(1,1);
        tree_init(tim);
        for(int i = 1; i < n; i++){
            int u = tmp[i].u, v = tmp[i].v;
            if(dep[u] > dep[v]){
                sgt[tid[u]+sgt_sz-1] = tmp[i].c;
            }
            else{
                sgt[tid[v]+sgt_sz-1] = tmp[i].c;
            }
        }
        build(0,0,sgt_sz-1);
        while(1){
            char op[10];
            scanf("%s", op);
            if(op[0] == 'D') break;
            int a,b; scanf("%d%d", &a, &b);
            if(op[0] == 'Q') printf("%d\n", solve(a,b));
            else    change(a,b);
        }
    }
    return 0;
}
